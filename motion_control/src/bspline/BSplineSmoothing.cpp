#include "bspline/BSplineSmoothing.h"

// 静态成员初始化
BSplineSmoothing* BSplineSmoothing::instance_ = nullptr;

// 私有构造函数
BSplineSmoothing::BSplineSmoothing(int degree, double maximum_error,
                                 int max_iterations, double tolerance)
    : degree_(degree), maximum_error_(maximum_error),
      max_iterations_(max_iterations), tolerance_(tolerance) {
    if (degree < 1) {
        throw std::invalid_argument("B样条次数必须大于等于1");
    }
    if (maximum_error <= 0) {
        throw std::invalid_argument("最大轮廓误差必须大于0");
    }
}

// 获取单例实例
BSplineSmoothing* BSplineSmoothing::getInstance(int degree, double maximum_error,
                                               int max_iterations, double tolerance) {
    if (instance_ == nullptr) {
        instance_ = new BSplineSmoothing(degree, maximum_error, max_iterations, tolerance);
    }
    return instance_;
}

// 销毁单例实例
void BSplineSmoothing::destroyInstance() {
    if (instance_ != nullptr) {
        delete instance_;
        instance_ = nullptr;
    }
}

// 设置参数
void BSplineSmoothing::setDegree(int degree) {
    if (degree < 1) {
        throw std::invalid_argument("B样条次数必须大于等于1");
    }
    degree_ = degree;
}

void BSplineSmoothing::setMaximumError(double maximum_error) {
    if (maximum_error <= 0) {
        throw std::invalid_argument("最大轮廓误差必须大于0");
    }
    maximum_error_ = maximum_error;
}

void BSplineSmoothing::setMaxIterations(int max_iterations) {
    max_iterations_ = max_iterations;
}

void BSplineSmoothing::setTolerance(double tolerance) {
    tolerance_ = tolerance;
}

// 生成平滑B样条曲线
void BSplineSmoothing::generateSmoothCurve(const LineSegment& seg1, const LineSegment& seg2,
                                         int numSamples) {
    // 找到交点
    Point3D intersection;
    if (!findIntersection(seg1, seg2, intersection)) {
        throw std::invalid_argument("线段不相交，无法进行平滑处理");
    }

    // 使用最大轮廓误差约束优化控制点
    std::vector<Point3D> controlPoints = optimizeControlPoints(seg1, seg2, intersection);

    // 生成B样条曲线并存储到成员变量
    smoothedCurve_ = generateBSplineCurve(controlPoints, numSamples);
}

// 计算点到B样条曲线的最短距离
double BSplineSmoothing::distanceToSpline(const Point3D& point, const std::vector<Point3D>& splinePoints) {
    if (splinePoints.empty()) return std::numeric_limits<double>::max();

    double minDistance = std::numeric_limits<double>::max();

    for (size_t i = 0; i < splinePoints.size(); ++i) {
        double dist = (point - splinePoints[i]).length();
        minDistance = std::min(minDistance, dist);
    }

    return minDistance;
}

// 验证轮廓误差
bool BSplineSmoothing::validateContourError(const Point3D& intersection, const std::vector<Point3D>& splinePoints) {
    double distance = distanceToSpline(intersection, splinePoints);
    return distance <= maximum_error_;
}

// 保存数据到文件
bool BSplineSmoothing::saveDataToFile(const LineSegment& seg1, const LineSegment& seg2,
                                     const std::vector<Point3D>& smoothedCurve,
                                     const std::string& filename) {
    std::ofstream dataFile(filename);
    if (!dataFile.is_open()) {
        std::cerr << "无法创建数据文件: " << filename << std::endl;
        return false;
    }

    try {
        // 保存文件头信息
        dataFile << "# B-Spline Smoothing Data File\n";
        dataFile << "# Generated by BSplineSmoothing Class\n";
        dataFile << "# Format: x y z\n";
        dataFile << "\n";

        // 保存B样条参数信息
        dataFile << "# B-Spline Parameters\n";
        dataFile << "# Degree: " << degree_ << "\n";
        dataFile << "# Maximum Error: " << maximum_error_ << "\n";
        dataFile << "# Max Iterations: " << max_iterations_ << "\n";
        dataFile << "# Tolerance: " << tolerance_ << "\n";
        dataFile << "\n";

        // 保存线段1的数据
        dataFile << "# Line Segment 1\n";
        dataFile << std::fixed << std::setprecision(6)
                << seg1.start.x << " " << seg1.start.y << " " << seg1.start.z << "\n";
        dataFile << std::fixed << std::setprecision(6)
                << seg1.end.x << " " << seg1.end.y << " " << seg1.end.z << "\n";
        dataFile << "\n";

        // 保存线段2的数据
        dataFile << "# Line Segment 2\n";
        dataFile << std::fixed << std::setprecision(6)
                << seg2.start.x << " " << seg2.start.y << " " << seg2.start.z << "\n";
        dataFile << std::fixed << std::setprecision(6)
                << seg2.end.x << " " << seg2.end.y << " " << seg2.end.z << "\n";
        dataFile << "\n";

        // 保存B样条曲线数据
        dataFile << "# B-Spline Curve Points (" << smoothedCurve.size() << " points)\n";
        for (const auto& point : smoothedCurve) {
            dataFile << std::fixed << std::setprecision(6)
                    << point.x << " " << point.y << " " << point.z << "\n";
        }

        // 保存统计信息
        dataFile << "\n# Statistics\n";
        dataFile << "# Total curve points: " << smoothedCurve.size() << "\n";
        if (!smoothedCurve.empty()) {
            dataFile << "# Start point: " << std::fixed << std::setprecision(6)
                    << smoothedCurve.front().x << " " << smoothedCurve.front().y << " " << smoothedCurve.front().z << "\n";
            dataFile << "# End point: " << std::fixed << std::setprecision(6)
                    << smoothedCurve.back().x << " " << smoothedCurve.back().y << " " << smoothedCurve.back().z << "\n";
        }

        dataFile.close();
        std::cout << "数据已保存到 " << filename << " 文件中" << std::endl;
        return true;

    } catch (const std::exception& e) {
        std::cerr << "保存文件时发生错误: " << e.what() << std::endl;
        dataFile.close();
        return false;
    }
}

// 根据比例获取B样条曲线上的点（支持线性插值）
Point3D BSplineSmoothing::get_BSpline_point(double ratio) {
    if (smoothedCurve_.empty()) {
        throw std::runtime_error("B样条曲线尚未生成，请先调用generateSmoothCurve函数");
    }

    // 限制ratio在[0, 1]范围内
    if (ratio < 0.0) ratio = 0.0;
    if (ratio > 1.0) ratio = 1.0;

    // 计算在曲线点数组中的位置
    double exactIndex = ratio * (smoothedCurve_.size() - 1);

    // 获取整数部分和小数部分
    int lowerIndex = static_cast<int>(std::floor(exactIndex));
    int upperIndex = static_cast<int>(std::ceil(exactIndex));
    double fraction = exactIndex - lowerIndex;

    // 边界检查
    if (lowerIndex < 0) lowerIndex = 0;
    if (upperIndex >= static_cast<int>(smoothedCurve_.size())) {
        upperIndex = smoothedCurve_.size() - 1;
    }

    // 如果索引相同或fraction为0，直接返回该点
    if (lowerIndex == upperIndex || fraction < 1e-10) {
        return smoothedCurve_[lowerIndex];
    }

    // 线性插值
    const Point3D& point1 = smoothedCurve_[lowerIndex];
    const Point3D& point2 = smoothedCurve_[upperIndex];

    return Point3D(
        point1.x + (point2.x - point1.x) * fraction,
        point1.y + (point2.y - point1.y) * fraction,
        point1.z + (point2.z - point1.z) * fraction
    );
}

// 获取B样条曲线的总路程（所有点之间距离的总和）
double BSplineSmoothing::getCurveLength() const {
    if (smoothedCurve_.size() < 2) {
        return 0.0;  // 少于2个点时，路程为0
    }

    double totalLength = 0.0;

    // 计算所有相邻点之间的距离并累加
    for (size_t i = 1; i < smoothedCurve_.size(); ++i) {
        double segmentLength = (smoothedCurve_[i] - smoothedCurve_[i-1]).length();
        totalLength += segmentLength;
    }

    return totalLength;
}

// B样条基函数计算
double BSplineSmoothing::basisFunction(int i, int k, double t, const std::vector<double>& knots) {
    // 递归终止条件：0次B样条
    if (k == 1) {
        if (knots[i] <= t && t < knots[i+1]) {
            return 1.0;
        }
        // 特殊处理：当t=1.0且在最后一个区间时
        if (t == 1.0 && knots[i] <= t && t <= knots[i+1]) {
            return 1.0;
        }
        return 0.0;
    }

    double denom1 = knots[i + k - 1] - knots[i];
    double denom2 = knots[i + k] - knots[i + 1];

    double term1 = 0.0;
    if (denom1 > 1e-10) {  // 避免除以零
        term1 = (t - knots[i]) / denom1 * basisFunction(i, k-1, t, knots);
    }

    double term2 = 0.0;
    if (denom2 > 1e-10) {  // 避免除以零
        term2 = (knots[i + k] - t) / denom2 * basisFunction(i + 1, k-1, t, knots);
    }

    return term1 + term2;
}

// 生成B样条节点向量
std::vector<double> BSplineSmoothing::generateKnotVector(int numControlPoints) {
    int n = numControlPoints - 1;  // 控制点索引上限
    int m = n + degree_ + 1;       // 节点数量
    std::vector<double> knots(m, 0.0);

    // 中间节点均匀分布
    for (int i = degree_ + 1; i <= n; ++i) {
        knots[i] = static_cast<double>(i - degree_) / (n - degree_ + 1);
    }

    // 末尾节点设为1.0
    for (int i = n + 1; i < m; ++i) {
        knots[i] = 1.0;
    }

    return knots;
}

// 在参数t处计算B样条曲线上的点
Point3D BSplineSmoothing::evaluateBSpline(double t, const std::vector<Point3D>& controlPoints,
                                         const std::vector<double>& knots) {
    int n = controlPoints.size() - 1;
    Point3D result(0, 0, 0);

    for (int i = 0; i <= n; ++i) {
        double b = basisFunction(i, degree_ + 1, t, knots);  // 阶数 = 次数 + 1
        result = result + controlPoints[i] * b;
    }

    return result;
}

// 寻找两条线段的交点
bool BSplineSmoothing::findIntersection(const LineSegment& seg1, const LineSegment& seg2, Point3D& intersection) {
    // 线段1: A + s*(B - A)
    // 线段2: C + t*(D - C)
    Point3D A = seg1.start;
    Point3D B = seg1.end;
    Point3D C = seg2.start;
    Point3D D = seg2.end;

    // 向量计算
    Point3D u = B - A;
    Point3D v = D - C;
    Point3D w = A - C;

    double a = u.x*u.x + u.y*u.y + u.z*u.z;  // |u|^2
    double b = u.x*v.x + u.y*v.y + u.z*v.z;  // u·v
    double c = v.x*v.x + v.y*v.y + v.z*v.z;  // |v|^2
    double d = u.x*w.x + u.y*w.y + u.z*w.z;  // u·w
    double e = v.x*w.x + v.y*w.y + v.z*w.z;  // v·w
    double denominator = a*c - b*b;

    // 检查线段是否平行
    if (std::fabs(denominator) < 1e-10) {
        return false;  // 平行或共线，无唯一交点
    }

    // 计算参数s和t
    double s = (b*e - c*d) / denominator;
    double t = (a*e - b*d) / denominator;

    // 检查s和t是否在线段范围内
    if (s >= -1e-10 && s <= 1.0 + 1e-10 && t >= -1e-10 && t <= 1.0 + 1e-10) {
        // 计算交点
        intersection = A + u * s;
        return true;
    }

    return false;  // 交点在线段延长线上，不在线段本身
}

// 使用最大轮廓误差约束优化控制点
std::vector<Point3D> BSplineSmoothing::optimizeControlPoints(const LineSegment& seg1, const LineSegment& seg2,
                                                            const Point3D& intersection) {
    // 计算线段方向向量
    Point3D dir1 = seg1.getDirection().normalize();
    Point3D dir2 = seg2.getDirection().normalize();

    // 初始偏移距离（基于最大轮廓误差的估算）
    double initial_offset = maximum_error_ * 2.0;
    double current_offset = initial_offset;

    std::vector<Point3D> bestControlPoints;
    double bestError = std::numeric_limits<double>::max();

    // 迭代优化控制点位置
    for (int iter = 0; iter < max_iterations_; ++iter) {
        // 在线段上取点
        Point3D p1 = intersection - dir1 * current_offset;
        Point3D p2 = intersection + dir2 * current_offset;

        // 创建控制点集
        std::vector<Point3D> controlPoints;
        controlPoints.push_back(p1);  // 线段1上的点
        controlPoints.push_back(Point3D(
            (p1.x + intersection.x) / 2,
            (p1.y + intersection.y) / 2,
            (p1.z + intersection.z) / 2
        ));  // 中间控制点1
        controlPoints.push_back(intersection);  // 交点
        controlPoints.push_back(Point3D(
            (intersection.x + p2.x) / 2,
            (intersection.y + p2.y) / 2,
            (intersection.z + p2.z) / 2
        ));  // 中间控制点2
        controlPoints.push_back(p2);  // 线段2上的点

        // 生成B样条曲线进行误差检验
        std::vector<Point3D> testCurve = generateBSplineCurve(controlPoints, 50);

        // 计算交点到曲线的最短距离
        double currentError = distanceToSpline(intersection, testCurve);

        // 检查是否满足误差约束
        if (currentError <= maximum_error_) {
            if (currentError < bestError) {
                bestError = currentError;
                bestControlPoints = controlPoints;
            }

            // 如果误差足够小，可以提前退出
            if (currentError < tolerance_) {
                break;
            }
        }

        // 调整偏移距离
        if (currentError > maximum_error_) {
            // 误差太大，减小偏移距离
            current_offset *= 0.8;
        } else {
            // 误差满足要求，可以尝试增大偏移距离以获得更平滑的曲线
            current_offset *= 1.1;
        }

        // 防止偏移距离过小或过大
        current_offset = std::max(current_offset, maximum_error_ * 0.1);
        current_offset = std::min(current_offset, maximum_error_ * 10.0);
    }

    // 如果没有找到满足约束的解，使用最小误差的解
    if (bestControlPoints.empty()) {
        std::cout << "警告: 无法满足最大轮廓误差约束，使用最小误差解" << std::endl;

        // 使用最小偏移距离创建控制点
        current_offset = maximum_error_ * 0.5;
        Point3D p1 = intersection - dir1 * current_offset;
        Point3D p2 = intersection + dir2 * current_offset;

        bestControlPoints.push_back(p1);
        bestControlPoints.push_back(Point3D(
            (p1.x + intersection.x) / 2,
            (p1.y + intersection.y) / 2,
            (p1.z + intersection.z) / 2
        ));
        bestControlPoints.push_back(intersection);
        bestControlPoints.push_back(Point3D(
            (intersection.x + p2.x) / 2,
            (intersection.y + p2.y) / 2,
            (intersection.z + p2.z) / 2
        ));
        bestControlPoints.push_back(p2);
    }

    return bestControlPoints;
}

// 生成B样条曲线
std::vector<Point3D> BSplineSmoothing::generateBSplineCurve(const std::vector<Point3D>& controlPoints,
                                                           int numSamples) {
    std::vector<Point3D> result;

    // 生成节点向量
    std::vector<double> knots = generateKnotVector(controlPoints.size());

    // 生成曲线上的采样点
    for (int i = 0; i <= numSamples; ++i) {
        double t = static_cast<double>(i) / numSamples;
        result.push_back(evaluateBSpline(t, controlPoints, knots));
    }

    return result;
}
